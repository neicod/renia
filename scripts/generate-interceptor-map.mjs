#!/usr/bin/env node
/**
 * Script to generate interceptor map for client-side dynamic imports.
 *
 * Sources of truth:
 * - Enabled modules: app/etc/config.json
 * - Interceptor files: <module>/interceptors/{default|<context>}.(ts|js)
 *
 * Writes: generated/interceptors/interceptorMap.generated.ts
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');

const readJson = (filePath) => JSON.parse(fs.readFileSync(filePath, 'utf-8'));

const listDirSorted = (dirPath) => {
  if (!fs.existsSync(dirPath)) return [];
  return fs.readdirSync(dirPath).slice().sort((a, b) => a.localeCompare(b));
};

const resolveNodeModulesPath = (moduleName) => {
  if (!moduleName || typeof moduleName !== 'string') return null;
  const nodeModulesDir = path.join(projectRoot, 'node_modules');
  if (moduleName.startsWith('@')) {
    const [scope, pkg] = moduleName.split('/', 2);
    if (!scope || !pkg) return null;
    const p = path.join(nodeModulesDir, scope, pkg);
    return fs.existsSync(p) ? p : null;
  }
  const p = path.join(nodeModulesDir, moduleName);
  return fs.existsSync(p) ? p : null;
};

const buildAppModulesIndex = () => {
  const out = new Map();
  const appModulesRoot = path.join(projectRoot, 'app/modules');
  if (!fs.existsSync(appModulesRoot)) return out;

  for (const vendor of listDirSorted(appModulesRoot)) {
    const vendorDir = path.join(appModulesRoot, vendor);
    if (!fs.existsSync(vendorDir) || !fs.statSync(vendorDir).isDirectory()) continue;

    for (const mod of listDirSorted(vendorDir)) {
      const modDir = path.join(vendorDir, mod);
      const pkgPath = path.join(modDir, 'package.json');
      if (!fs.existsSync(pkgPath)) continue;
      try {
        const pkg = readJson(pkgPath);
        if (pkg?.name && typeof pkg.name === 'string') {
          out.set(pkg.name, modDir);
        }
      } catch {
        // ignore invalid package.json
      }
    }
  }
  return out;
};

const appModulesIndex = buildAppModulesIndex();

const resolveModuleDir = (moduleName) => {
  const fromNodeModules = resolveNodeModulesPath(moduleName);
  if (fromNodeModules) return fromNodeModules;
  const fromAppModules = appModulesIndex.get(moduleName) ?? null;
  if (fromAppModules && fs.existsSync(fromAppModules)) return fromAppModules;
  return null;
};

// 1) enabled modules
const configPath = path.join(projectRoot, 'app/etc/config.json');
const config = readJson(configPath);
const enabledModules = Object.entries(config.modules ?? {})
  .filter(([, enabled]) => Boolean(enabled))
  .map(([name]) => name)
  .sort((a, b) => a.localeCompare(b));

console.log(`Found ${enabledModules.length} enabled modules`);

// 2) scan interceptor files
const interceptorMap = {};

for (const moduleName of enabledModules) {
  const moduleDir = resolveModuleDir(moduleName);
  if (!moduleDir) {
    console.warn(`⚠ Enabled module "${moduleName}" not found in node_modules or app/modules`);
    continue;
  }

  const interceptorsDir = path.join(moduleDir, 'interceptors');
  if (!fs.existsSync(interceptorsDir) || !fs.statSync(interceptorsDir).isDirectory()) {
    continue;
  }

  const files = listDirSorted(interceptorsDir).filter((f) => {
    if (f.endsWith('.d.ts')) return false;
    return f.endsWith('.ts') || f.endsWith('.js');
  });

  if (!files.length) continue;

  interceptorMap[moduleName] = {};
  for (const file of files) {
    const contextName = file.replace(/\.(ts|js)$/, '');
    interceptorMap[moduleName][contextName] = {
      importPath: `${moduleName}/interceptors/${contextName}`,
      required: contextName === 'default'
    };
  }
}

console.log(`Found interceptors for ${Object.keys(interceptorMap).length} modules`);

// 3) generate TS
const generateTypeScript = () => {
  const entries = Object.entries(interceptorMap).sort((a, b) => a[0].localeCompare(b[0]));

  let code = `// @env: browser
/**
 * AUTOGENERATED INTERCEPTOR MAP
 * Generated by: scripts/generate-interceptor-map.mjs
 * WARNING: Do not edit manually! Changes will be overwritten.
 */

export type InterceptorLoaders = {
  default?: () => Promise<any>;
  [context: string]: (() => Promise<any>) | undefined;
};

export const interceptorMap: Record<string, InterceptorLoaders> = {
`;

  for (const [moduleName, contexts] of entries) {
    code += `  '${moduleName}': {\n`;
    const sortedContexts = Object.entries(contexts).sort((a, b) => a[0].localeCompare(b[0]));
    for (const [contextName, { importPath, required }] of sortedContexts) {
      const catchClause = required ? '' : '.catch(() => null)';
      code += `    '${contextName}': () => import('${importPath}')${catchClause},\n`;
    }
    code += `  },\n`;
  }

  code += `};\n`;
  return code;
};

const generatedCode = generateTypeScript();

// 4) validate contexts referenced in routes.ts (best-effort)
const validateContexts = () => {
  const issues = [];
  const hasContext = (contextName) =>
    Object.values(interceptorMap).some((ctxMap) => ctxMap && Object.prototype.hasOwnProperty.call(ctxMap, contextName));

  for (const moduleName of enabledModules) {
    const moduleDir = resolveModuleDir(moduleName);
    if (!moduleDir) continue;
    const routesCandidates = [path.join(moduleDir, 'routes.ts'), path.join(moduleDir, 'routes.js')];
    const routesPath = routesCandidates.find((p) => fs.existsSync(p));
    if (!routesPath) continue;

    try {
      const content = fs.readFileSync(routesPath, 'utf-8');
      const contextsMatches = content.match(/contexts\\s*:\\s*\\[(.*?)\\]/g) || [];
      for (const match of contextsMatches) {
        const contexts = match.match(/'([^']+)'/g) || [];
        for (const ctx of contexts) {
          const contextName = ctx.replace(/'/g, '');
          if (contextName === 'default') continue;
          if (!hasContext(contextName)) {
            issues.push(`Module ${moduleName}: context '${contextName}' not found in interceptors`);
          }
        }
      }
    } catch {
      // ignore parse errors
    }
  }
  return issues;
};

const validationIssues = validateContexts();
if (validationIssues.length > 0) {
  console.log('\\nValidation info (contexts referenced in routes that are not present in interceptors map):');
  validationIssues.forEach((issue) => console.log(`  ℹ ${issue}`));
}

// 5) write file
const outputDir = path.join(projectRoot, 'generated/interceptors');
fs.mkdirSync(outputDir, { recursive: true });
const outputPath = path.join(outputDir, 'interceptorMap.generated.ts');
fs.writeFileSync(outputPath, generatedCode, 'utf-8');

console.log(`Generated map: ${path.relative(projectRoot, outputPath)}`);
console.log(`  Modules: ${Object.keys(interceptorMap).length}`);
console.log(
  `  Contexts: ${Object.values(interceptorMap).reduce((sum, ctxs) => sum + Object.keys(ctxs).length, 0)}`
);
