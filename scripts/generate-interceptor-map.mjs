#!/usr/bin/env node
/**
 * Script to generate interceptor map from available files.
 * Scans:
 * 1. app/etc/config.json - which modules are enabled
 * 2. app/modules - what contexts we have from routes.ts
 * 3. app/modules - what interceptors exist
 *
 * Generates: src/framework/interceptors/interceptorMap.generated.ts
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');

// 1. Load module configuration
const configPath = path.join(projectRoot, 'app/etc/config.json');
const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
const enabledModules = Object.entries(config.modules)
  .filter(([_, enabled]) => enabled)
  .map(([name]) => name);

console.log(`Found ${enabledModules.length} enabled modules`);

// 2. Build module directory map
const moduleDirs = fs.readdirSync(path.join(projectRoot, 'app/modules/renia'));
const moduleNameToDir = {};

for (const dir of moduleDirs) {
  // Try to find which config module this directory corresponds to
  // Usually: renia-magento-cart -> magento-cart, graphql-client -> graphql-client
  const dirName = dir; // e.g., 'magento-cart'

  // Find matching module in config
  for (const moduleName of enabledModules) {
    // Check if module name matches directory
    if (moduleName === dirName || moduleName === `renia-${dirName}` || moduleName.endsWith(`/${dirName}`)) {
      moduleNameToDir[moduleName] = dirName;
      break;
    }
    // Also check if directory is in the module name
    if (moduleName.includes(dirName)) {
      moduleNameToDir[moduleName] = dirName;
      break;
    }
  }
}

// 3. Scan interceptors for each module
const interceptorMap = {};

for (const moduleName of enabledModules) {
  const dirName = moduleNameToDir[moduleName] || moduleName.replace('renia-', '');
  const modulePath = path.join(projectRoot, 'app/modules/renia', dirName);
  const interceptorsDir = path.join(modulePath, 'interceptors');

  if (!fs.existsSync(interceptorsDir)) {
    continue; // Module has no interceptors
  }

  const files = fs.readdirSync(interceptorsDir).filter(f => f.endsWith('.ts'));

  if (files.length === 0) {
    continue;
  }

  interceptorMap[moduleName] = {};

  for (const file of files) {
    const contextName = file.replace('.ts', '');
    const importPath = `${moduleName}/interceptors/${contextName}`;

    // Determine if this interceptor is required or optional
    // If it's default, it's required. Otherwise optional.
    const isRequired = contextName === 'default';

    interceptorMap[moduleName][contextName] = {
      path: importPath,
      required: isRequired
    };
  }
}

console.log(`Found interceptors for ${Object.keys(interceptorMap).length} modules`);

// 4. Generate TypeScript code
const generateTypeScript = () => {
  const entries = Object.entries(interceptorMap).sort((a, b) => a[0].localeCompare(b[0]));

  let code = `// @env: browser
/**
 * AUTOGENERATED INTERCEPTOR MAP
 * Generated by: scripts/generate-interceptor-map.mjs
 * WARNING: Do not edit manually! Changes will be overwritten.
 */

export type InterceptorLoaders = {
  default?: () => Promise<any>;
  [context: string]: (() => Promise<any>) | undefined;
};

// Map: module -> context -> loader
export const interceptorMap: Record<string, InterceptorLoaders> = {
`;

  for (const [moduleName, contexts] of entries) {
    code += `  '${moduleName}': {\n`;

    const sortedContexts = Object.entries(contexts).sort((a, b) => a[0].localeCompare(b[0]));
    for (const [contextName, { path: importPath, required }] of sortedContexts) {
      const catchClause = required ? '' : ".catch(() => null)";
      code += `    ${contextName}: () => import('${importPath}')${catchClause},\n`;
    }

    code += `  },\n`;
  }

  code += `};\n`;

  return code;
};

const generatedCode = generateTypeScript();

// 5. Validate: Check if all contexts from routes are available in interceptorMap
const validateContexts = () => {
  const routesFiles = [];
  const appModulesDir = path.join(projectRoot, 'app/modules/renia');

  // Find all routes.ts files
  for (const dir of fs.readdirSync(appModulesDir)) {
    const routesFile = path.join(appModulesDir, dir, 'routes.ts');
    if (fs.existsSync(routesFile)) {
      routesFiles.push({ module: dir, path: routesFile });
    }
  }

  const issues = [];

  // Check each routes file
  for (const { module, path: routesPath } of routesFiles) {
    try {
      const content = fs.readFileSync(routesPath, 'utf-8');

      // Simple regex to find contexts arrays
      const contextsMatches = content.match(/contexts\s*:\s*\[(.*?)\]/g) || [];

      for (const match of contextsMatches) {
        // Extract context strings
        const contexts = match.match(/'([^']+)'/g) || [];
        for (const ctx of contexts) {
          const contextName = ctx.replace(/'/g, '');

          // Check if any module has this context
          const hasContext = Object.values(interceptorMap).some(
            contexts => contextName in contexts
          );

          if (!hasContext && contextName !== 'default') {
            issues.push(`Module ${module}: context '${contextName}' not found in interceptors`);
          }
        }
      }
    } catch (error) {
      // Silently skip files that can't be parsed
    }
  }

  return issues;
};

const validationIssues = validateContexts();
if (validationIssues.length > 0) {
  console.log('\nValidation info (contexts from routes that are not in enabled modules):');
  validationIssues.forEach(issue => console.log(`  â„¹ ${issue}`));
}

// 6. Write file
const outputPath = path.join(projectRoot, 'src/framework/interceptors/interceptorMap.generated.ts');
fs.writeFileSync(outputPath, generatedCode, 'utf-8');

console.log(`Generated map: ${path.relative(projectRoot, outputPath)}`);
console.log(`  Modules: ${Object.keys(interceptorMap).length}`);
console.log(`  Contexts: ${Object.values(interceptorMap).reduce((sum, c) => sum + Object.keys(c).length, 0)}`);
